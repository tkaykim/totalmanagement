TECHNICAL SPECIFICATION: Unified Partner Database Integration

1. Objective

Refactor the fragmented entity tables (artists, dancers, dance_team, partner_company, partner_worker, creators) into a single, robust partners table with a flexible N:M relationship structure.

This change acknowledges that an individual (Artist/Dancer) can belong to multiple organizations (Teams/Companies) simultaneously or historically.

Scope:

Create partners table (Polymorphic design).

Create partner_relations table to handle Many-to-Many affiliations.

Migrate data from legacy tables.

Refactor projects, financial_entries to point to the new partners table.

Implement logic to distinguish Internal (Exclusive) vs External entities via relations.

2. Database Schema Refactoring

A. Core Concept: partners (Entities) & partner_relations (Connections)

Instead of a simple parent column, we use a dedicated relation table.

-- 1. Create Enum Types
CREATE TYPE partner_type AS ENUM ('organization', 'individual', 'team');
CREATE TYPE partner_category AS ENUM ('client', 'vendor', 'artist', 'dancer', 'creator', 'employee_external', 'internal_staff');
CREATE TYPE relation_type AS ENUM ('exclusive', 'agency', 'member', 'project_contract');

-- 2. Main Unified Table: partners (Entity Only)
CREATE TABLE public.partners (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bu_code USER-DEFINED NOT NULL REFERENCES public.business_units(code),
    
    -- Basic Identity
    name text NOT NULL,
    display_name text,
    
    -- Classification
    type partner_type NOT NULL, -- Entity structure
    category partner_category NOT NULL, -- Business role (Primary role)
    
    -- Contact Info
    email text,
    phone text,
    website_url text,
    
    -- Flexible Metadata (Visa, Bank, Specs)
    metadata jsonb DEFAULT '{}'::jsonb,
    
    -- Status Management
    is_active boolean DEFAULT true,
    tags text[],
    
    -- Audit
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),
    deleted_at timestamptz
);

-- 3. Relation Table: partner_relations (N:M Support)
-- Stores: Who belongs to Whom (Dancer -> Team, Artist -> Agency)
CREATE TABLE public.partner_relations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Hierarchy: Parent (Organization/Team) <-> Child (Individual)
    parent_partner_id bigint NOT NULL REFERENCES public.partners(id),
    child_partner_id bigint NOT NULL REFERENCES public.partners(id),
    
    -- Relation Details
    relation_type relation_type NOT NULL DEFAULT 'member',
    role_in_team text, -- e.g., 'Leader', 'Main Dancer'
    
    -- Period Tracking
    start_date date,
    end_date date,
    is_active boolean DEFAULT true,
    
    created_at timestamptz DEFAULT now(),
    
    -- Constraint: Prevent duplicate active relations of same type
    UNIQUE (parent_partner_id, child_partner_id, relation_type)
);

-- Indexes
CREATE INDEX idx_partners_metadata ON public.partners USING gin (metadata);
CREATE INDEX idx_relations_parent ON public.partner_relations (parent_partner_id);
CREATE INDEX idx_relations_child ON public.partner_relations (child_partner_id);


B. Migration Strategy

The agent must execute this in a transaction.

Backup: Snapshot current tables.

Insert Organizations:

Create "Grigo Entertainment" partner record manually (if not exists).

Migrate partner_company → partners (Type: Organization).

Migrate dance_team → partners (Type: Team).

Insert Individuals:

Migrate artists, dancers, partner_worker → partners (Type: Individual).

Migrate Relations (Crucial Step):

Internal Artists: For artists with bu_code='GRIGO', insert into partner_relations:

parent: ID of "Grigo Ent", child: Artist ID, type: 'exclusive'.

Team Members: For dancer_team_mapping (Legacy), insert into partner_relations:

parent: Team ID, child: Dancer ID, type: 'member'.

Company Workers: For partner_worker, insert into partner_relations:

parent: Partner Company ID, child: Worker ID, type: 'member'.

3. Backend Logic & API Layer

A. RLS Policies

partners: Same as before (Basic Info Public, Metadata Restricted).

partner_relations:

SELECT: Visible to all authenticated users (to see who is in which team).

INSERT/UPDATE: Restricted to manager or admin.

B. Search Logic (Updated for N:M)

Find "Our Artists" (Internal) or "Team Members".

-- Find all members of a specific Organization/Team
-- usage: select * from get_team_members(team_id)
CREATE OR REPLACE FUNCTION get_team_members(target_team_id bigint)
RETURNS TABLE (
    member_id bigint, 
    member_name text, 
    role text, 
    is_active boolean
) AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.name, pr.role_in_team, pr.is_active
  FROM partners p
  JOIN partner_relations pr ON p.id = pr.child_partner_id
  WHERE pr.parent_partner_id = target_team_id
  AND pr.is_active = true
  AND p.deleted_at IS NULL;
END;
$$ LANGUAGE plpgsql;


4. Frontend UI/UX Structure

A. Page: /erp/partners

Filters: "Internal (Grigo)", "External", "Teams".

Logic: "Internal" filter queries partner_relations where parent_id = GRIGO_ID.

B. Component: PartnerDetailModal

Tab: "Affiliations" (New):

List of teams/companies this person belongs to.

Action: "Add Affiliation" button.

Inputs: Select Organization (Autocomplete), Role (Text), Relation Type (Enum).

Example: A dancer can be listed as "Member" of 'Just Jerk' AND "Contractor" for 'Grigo Project A'.

C. Project Assignment UI

When assigning a task to a Team (e.g., 'Team A'), the UI should optionally allow expanding to select specific Members of that team using the get_team_members RPC.

5. Execution Plan for AI Agent

Analyze: Read existing dancer_team_mapping table to understand current N:M implementation.

Schema Change: Create partners AND partner_relations tables.

Data Script:

Migrate Entities first.

Migrate Relations second (Populate partner_relations from legacy mappings).

Refactor References: Update projects.partner_id to point to partners.id.

Validation: Ensure a dancer belonging to 2 teams in the old DB has 2 rows in partner_relations.

Cleanup: Rename old tables after confirmation.